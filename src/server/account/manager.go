package account

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"os"
	"path/filepath"
	"sync"

	"github.com/skycoin/skycoin/src/util/file"
)

type Manager interface {
	CreateAccountWithPubkey(pk string) (Accounter, error)
	GetAccount(id string) (Accounter, error)
	Save() error
}

// AccountManager manage all the accounts in the server.
type ExchangeAccountManager struct {
	Accounts map[string]*ExchangeAccount `json:"accounts"`
	mtx      sync.RWMutex
}

type exchgAcntMgrJson struct {
	Accounts []exchgAcntJson `json:"accounts"`
}

// NewAccountManager
func NewManager() Manager {
	return &ExchangeAccountManager{
		Accounts: make(map[string]*ExchangeAccount),
		// AcntMgrFileName: fileName,
	}
}

// LoadAccountManager from local disk.
func LoadManager() (Manager, error) {
	p := filepath.Join(acntDir, acntName)
	if _, err := os.Stat(p); os.IsNotExist(err) {
		return nil, err
	}

	a := exchgAcntMgrJson{}
	d, err := ioutil.ReadFile(p)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(d, &a); err != nil {
		return nil, err
	}
	return a.ToExchgAcntMgr(), nil
}

// CreateAccountWithPubkey create an accounter with specific pubkey, this pubkey is generated by client.
func (self *ExchangeAccountManager) CreateAccountWithPubkey(pubkey string) (Accounter, error) {
	self.mtx.Lock()
	defer self.mtx.Unlock()
	// check duplicate
	if _, ok := self.Accounts[pubkey]; ok {
		return nil, errors.New("duplicate account id")
	}
	at := newExchangeAccount(pubkey)
	self.Accounts[pubkey] = &at

	// save the account into disk
	if err := self.save(); err != nil {
		return nil, err
	}

	return &at, nil
}

// GetAccount return the account of specific id.
func (self *ExchangeAccountManager) GetAccount(id string) (Accounter, error) {
	self.mtx.RLock()
	defer self.mtx.RUnlock()
	if account, ok := self.Accounts[id]; ok {
		return account, nil
	} else {
		return nil, errors.New("account does not exist")
	}
}

func (self ExchangeAccountManager) ToMarshalable() exchgAcntMgrJson {
	amj := exchgAcntMgrJson{}

	for _, acnt := range self.Accounts {
		amj.Accounts = append(amj.Accounts, acnt.ToMarshalable())
	}
	return amj
}

func (self *ExchangeAccountManager) Save() error {
	self.mtx.Lock()
	defer self.mtx.Unlock()
	return self.save()
}

// persistance to disc. Save as JSON
func (self *ExchangeAccountManager) save() error {
	logger.Debug("save accounts")
	a := self.ToMarshalable()
	// for self.Accounts
	return file.SaveJSON(filepath.Join(acntDir, acntName), a, 0600)
}

func (self exchgAcntMgrJson) ToExchgAcntMgr() *ExchangeAccountManager {
	acntMap := make(map[string]*ExchangeAccount, len(self.Accounts))
	for _, acnt := range self.Accounts {
		at := acnt.ToExchgAcnt()
		acntMap[at.ID] = at
	}
	return &ExchangeAccountManager{
		Accounts: acntMap,
	}
}
